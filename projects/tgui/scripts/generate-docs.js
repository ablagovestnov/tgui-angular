#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * Улучшенный скрипт для генерации API документации библиотеки TGUI Angular
 * 
 * Возможности:
 * 1. Генерирует documentation.json через compodoc (оптимизированный)
 * 2. Создает API_REFERENCE.md для AI и разработчиков
 * 3. Создает API_SCHEMA.json для машинного чтения
 * 4. Валидация и проверка качества документации
 * 5. Кэширование для улучшения производительности
 * 6. Подробная отчетность
 */

const PROJECT_ROOT = path.resolve(__dirname, '..');
const SRC_DIR = path.join(PROJECT_ROOT, 'src');
const DOCS_OUTPUT_DIR = path.join(PROJECT_ROOT, 'docs');
const DIST_DIR = path.resolve(PROJECT_ROOT, '../../dist/tgui');
const CACHE_DIR = path.join(PROJECT_ROOT, '.docs-cache');

console.log('🚀 Starting Enhanced API Documentation Generation...');
console.log(`📁 Project root: ${PROJECT_ROOT}`);
console.log(`📁 Source directory: ${SRC_DIR}`);
console.log(`📁 Docs output: ${DOCS_OUTPUT_DIR}`);
console.log(`📁 Dist directory: ${DIST_DIR}`);

// Создаем необходимые директории
[DOCS_OUTPUT_DIR, CACHE_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`📁 Created directory: ${path.relative(PROJECT_ROOT, dir)}`);
  }
});

// Конфигурация генерации
const config = {
  generateDocumentationJson: true,
  generateApiReference: true,
  generateApiSchema: true,
  validateOutput: true,
  copyToDist: true,
  enableCaching: true,
  verbose: process.argv.includes('--verbose')
};

const stats = {
  startTime: Date.now(),
  components: 0,
  directives: 0,
  services: 0,
  interfaces: 0,
  filesGenerated: []
};

try {
  // Проверяем изменения для кэширования
  if (config.enableCaching && !shouldRegenerate()) {
    console.log('📦 Using cached documentation (no source changes detected)');
    copyToDistIfNeeded();
    process.exit(0);
  }

  // Шаг 1: Генерируем documentation.json через compodoc
  console.log('\n📖 Step 1: Generating documentation.json with compodoc...');
  
  const compodocCommand = buildCompodocCommand();
  
  if (config.verbose) {
    console.log(`🔧 Running: ${compodocCommand}`);
  }

  execSync(compodocCommand, { 
    cwd: PROJECT_ROOT,
    stdio: config.verbose ? 'inherit' : 'pipe'
  });

  const documentationJsonPath = path.join(DOCS_OUTPUT_DIR, 'documentation.json');
  
  if (!fs.existsSync(documentationJsonPath)) {
    throw new Error('documentation.json was not generated by compodoc');
  }

  console.log('✅ documentation.json generated successfully');
  stats.filesGenerated.push('documentation.json');

  // Читаем и парсим documentation.json
  const docData = JSON.parse(fs.readFileSync(documentationJsonPath, 'utf8'));
  
  // Обновляем статистику
  stats.components = (docData.components || []).length;
  stats.directives = (docData.directives || []).length;
  stats.services = (docData.injectables || []).length;
  stats.interfaces = (docData.interfaces || []).length;

  // Шаг 2: Генерируем API_REFERENCE.md
  if (config.generateApiReference) {
    console.log('\n📝 Step 2: Generating API_REFERENCE.md...');
    const apiReference = generateApiReference(docData);
    const apiRefPath = path.join(DOCS_OUTPUT_DIR, 'API_REFERENCE.md');
    fs.writeFileSync(apiRefPath, apiReference);
    console.log('✅ API_REFERENCE.md generated successfully');
    stats.filesGenerated.push('API_REFERENCE.md');
  }

  // Шаг 3: Генерируем API_SCHEMA.json
  if (config.generateApiSchema) {
    console.log('\n🔧 Step 3: Generating API_SCHEMA.json...');
    const apiSchema = generateApiSchema(docData);
    const apiSchemaPath = path.join(DOCS_OUTPUT_DIR, 'API_SCHEMA.json');
    fs.writeFileSync(apiSchemaPath, JSON.stringify(apiSchema, null, 2));
    console.log('✅ API_SCHEMA.json generated successfully');
    stats.filesGenerated.push('API_SCHEMA.json');
  }

  // Шаг 4: Валидация
  if (config.validateOutput) {
    console.log('\n🔍 Step 4: Validating generated documentation...');
    validateDocumentation(docData);
    console.log('✅ Documentation validation passed');
  }

  // Шаг 5: Копируем файлы в dist если существует
  if (config.copyToDist) {
    copyToDistIfNeeded();
  }

  // Шаг 6: Обновляем кэш
  if (config.enableCaching) {
    updateCache();
  }

  // Финальный отчет
  printFinalReport();

  console.log('\n🎉 Enhanced API documentation generation completed successfully!');
  
} catch (error) {
  console.error('\n❌ Error generating documentation:', error.message);
  if (config.verbose) {
    console.error(error.stack);
  }
  process.exit(1);
}

/**
 * Строит команду compodoc с оптимальными параметрами
 */
function buildCompodocCommand() {
  return [
    'npx compodoc',
    '--tsconfig', path.join(PROJECT_ROOT, 'tsconfig.lib.json'),
    '--output', DOCS_OUTPUT_DIR,
    '--exportFormat', 'json',
    '--name', '"TGUI Angular API Documentation"',
    '--silent',
    '--disableSourceCode',
    '--disableGraph', 
    '--disablePrivate',
    '--disableProtected',
    '--disableInternal',
    '--hideGenerator',
    '--disableDependencies',
    '--disableLifeCycleHooks'
  ].join(' ');
}

/**
 * Проверяет нужно ли перегенерировать документацию
 */
function shouldRegenerate() {
  const cacheFile = path.join(CACHE_DIR, 'last-generation.json');
  
  if (!fs.existsSync(cacheFile)) {
    return true;
  }

  try {
    const cacheData = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));
    const lastGenTime = new Date(cacheData.timestamp);
    
    // Проверяем изменения в исходных файлах
    const sourceFiles = getSourceFiles();
    const hasChanges = sourceFiles.some(file => {
      const stat = fs.statSync(file);
      return stat.mtime > lastGenTime;
    });

    return hasChanges;
  } catch {
    return true;
  }
}

/**
 * Получает список всех исходных файлов для отслеживания изменений
 */
function getSourceFiles() {
  const files = [];
  
  function walkDir(dir) {
    if (!fs.existsSync(dir)) return;
    
    fs.readdirSync(dir).forEach(file => {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !file.startsWith('.')) {
        walkDir(fullPath);
      } else if (file.endsWith('.ts') || file.endsWith('.json')) {
        files.push(fullPath);
      }
    });
  }
  
  walkDir(SRC_DIR);
  files.push(path.join(PROJECT_ROOT, 'tsconfig.lib.json'));
  files.push(path.join(PROJECT_ROOT, 'package.json'));
  
  return files;
}

/**
 * Копирует документацию в dist если необходимо
 */
function copyToDistIfNeeded() {
  if (fs.existsSync(DIST_DIR)) {
    console.log('\n📦 Copying documentation to dist...');
    
    stats.filesGenerated.forEach(file => {
      const src = path.join(DOCS_OUTPUT_DIR, file);
      const dest = path.join(DIST_DIR, file);
      if (fs.existsSync(src)) {
        fs.copyFileSync(src, dest);
        console.log(`✅ Copied ${file} to dist`);
      }
    });
  } else {
    console.log('ℹ️ Dist directory not found, skipping copy step');
  }
}

/**
 * Обновляет кэш после успешной генерации
 */
function updateCache() {
  const cacheData = {
    timestamp: new Date().toISOString(),
    stats: stats,
    config: config
  };
  
  fs.writeFileSync(
    path.join(CACHE_DIR, 'last-generation.json'),
    JSON.stringify(cacheData, null, 2)
  );
}

/**
 * Валидирует сгенерированную документацию
 */
function validateDocumentation(docData) {
  const issues = [];

  // Проверяем компоненты без описания
  const componentsWithoutDesc = (docData.components || []).filter(c => !c.description);
  if (componentsWithoutDesc.length > 0) {
    issues.push(`${componentsWithoutDesc.length} components without description`);
  }

  // Проверяем отсутствующие селекторы
  const componentsWithoutSelector = (docData.components || []).filter(c => !c.selector);
  if (componentsWithoutSelector.length > 0) {
    issues.push(`${componentsWithoutSelector.length} components without selector`);
  }

  // Проверяем размер файла документации
  const docJsonPath = path.join(DOCS_OUTPUT_DIR, 'documentation.json');
  const docSize = fs.statSync(docJsonPath).size;
  if (docSize < 10000) { // Меньше 10KB подозрительно
    issues.push(`documentation.json is suspiciously small (${Math.round(docSize/1024)}KB)`);
  }

  if (issues.length > 0) {
    console.warn('⚠️ Documentation validation warnings:');
    issues.forEach(issue => console.warn(`   - ${issue}`));
  }
}

/**
 * Выводит финальный отчет о генерации
 */
function printFinalReport() {
  const duration = Math.round((Date.now() - stats.startTime) / 1000);
  
  console.log('\n📊 Generation Summary:');
  console.log(`   ⏱️ Duration: ${duration}s`);
  console.log(`   📦 Components: ${stats.components}`);
  console.log(`   🎯 Directives: ${stats.directives}`);
  console.log(`   🔧 Services: ${stats.services}`);
  console.log(`   📋 Interfaces: ${stats.interfaces}`);
  console.log(`   📄 Files generated: ${stats.filesGenerated.join(', ')}`);
  
  // Показываем размеры файлов
  console.log('\n📏 File sizes:');
  stats.filesGenerated.forEach(file => {
    const filePath = path.join(DOCS_OUTPUT_DIR, file);
    if (fs.existsSync(filePath)) {
      const size = fs.statSync(filePath).size;
      console.log(`   ${file}: ${formatFileSize(size)}`);
    }
  });
}

/**
 * Форматирует размер файла в читаемом виде
 */
function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + 'B';
  if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + 'KB';
  return Math.round(bytes / (1024 * 1024) * 10) / 10 + 'MB';
}

/**
 * Генерирует API_REFERENCE.md на основе documentation.json
 */
function generateApiReference(docData) {
  const components = docData.components || [];
  const directives = docData.directives || [];
  const injectables = docData.injectables || [];
  const interfaces = docData.interfaces || [];
  
  let markdown = `# TGUI Angular - API Reference for AI

*Generated automatically from TypeScript source code*

## Library Overview

**TGUI Angular** is a comprehensive Angular UI component library designed specifically for building Telegram Web Apps. It provides modern, accessible components with automatic theme detection and platform-specific styling.

**Package Name:** \`tgui-angular\`
**Installation:** \`npm install tgui-angular\`
**Version:** ${docData.miscellaneous?.variables?.find(v => v.name === 'version')?.defaultValue || '1.0.x'}

## Required Setup

### Root Component (MANDATORY)
\`\`\`typescript
import { RootComponent } from 'tgui-angular';

@Component({
  template: \`
    <tgui-root [platform]="'ios'" [appearance]="'dark'">
      <!-- All app content must be inside tgui-root -->
    </tgui-root>
  \`,
  imports: [RootComponent]
})
\`\`\`

## Components

`;

  // Группируем компоненты по типам
  const componentGroups = {
    'blocks': [],
    'form': [],
    'typography': [],
    'navigation': [],
    'feedback': [],
    'overlays': [],
    'layout': [],
    'misc': [],
    'utils': []
  };

  components.forEach(component => {
    const filePath = component.file || '';
    let group = 'misc';
    
    // Определяем группу по пути к файлу
    if (filePath.includes('/blocks/')) group = 'blocks';
    else if (filePath.includes('/form/')) group = 'form';
    else if (filePath.includes('/typography/')) group = 'typography';
    else if (filePath.includes('/navigation/')) group = 'navigation';
    else if (filePath.includes('/feedback/')) group = 'feedback';
    else if (filePath.includes('/overlays/')) group = 'overlays';
    else if (filePath.includes('/layout/')) group = 'layout';
    else if (filePath.includes('/utils/')) group = 'utils';

    componentGroups[group].push(component);
  });

  // Генерируем документацию для каждой группы
  Object.entries(componentGroups).forEach(([groupName, groupComponents]) => {
    if (groupComponents.length > 0) {
      markdown += `\n### ${groupName.toUpperCase()} Components\n\n`;
      
      groupComponents.forEach(component => {
        markdown += generateComponentDoc(component);
      });
    }
  });

  // Добавляем сервисы
  if (injectables.length > 0) {
    markdown += `\n## Services\n\n`;
    injectables.forEach(service => {
      markdown += generateServiceDoc(service);
    });
  }

  // Добавляем директивы
  if (directives.length > 0) {
    markdown += `\n## Directives\n\n`;
    directives.forEach(directive => {
      markdown += generateDirectiveDoc(directive);
    });
  }

  // Добавляем интерфейсы
  if (interfaces.length > 0) {
    markdown += `\n## Interfaces & Types\n\n`;
    interfaces.forEach(iface => {
      markdown += generateInterfaceDoc(iface);
    });
  }

  markdown += `\n## Best Practices for AI Usage

### 1. Always Wrap in Root Component
\`\`\`typescript
// ✅ Correct
<tgui-root>
  <tgui-section>
    <tgui-button>Action</tgui-button>
  </tgui-section>
</tgui-root>

// ❌ Incorrect
<tgui-button>Action</tgui-button>
\`\`\`

### 2. Import Strategy
\`\`\`typescript
// ✅ Recommended - Import specific components
import { ButtonComponent, InputComponent } from 'tgui-angular';

// ❌ Avoid - Importing everything
import * from 'tgui-angular';
\`\`\`

*This documentation is automatically generated from TypeScript source code and JSDoc comments.*
`;

  return markdown;
}

/**
 * Генерирует документацию для компонента
 */
function generateComponentDoc(component) {
  const name = component.name;
  const selector = component.selector || 'N/A';
  const description = component.description || 'No description available';
  const filePath = component.file || '';
  
  let markdown = `#### ${name}\n\n`;
  markdown += `**Selector:** \`${selector}\`\n\n`;
  markdown += `${description}\n\n`;
  
  // Добавляем информацию о файле для контекста
  if (filePath) {
    const relativePath = filePath.replace(/.*\/src\//, 'src/');
    markdown += `**Source:** \`${relativePath}\`\n\n`;
  }
  
  // Добавляем импорт
  markdown += `**Import:**\n\`\`\`typescript\nimport { ${name} } from 'tgui-angular';\n\`\`\`\n\n`;
  
  // Добавляем свойства/инпуты
  if (component.inputsClass && component.inputsClass.length > 0) {
    markdown += `**Properties:**\n\n`;
    component.inputsClass.forEach(input => {
      const defaultValue = input.defaultValue ? ` (default: \`${input.defaultValue}\`)` : '';
      const required = input.optional === false ? ' **[required]**' : '';
      markdown += `- \`${input.name}\`: \`${input.type || 'any'}\`${required}${defaultValue} - ${input.description || 'No description'}\n`;
    });
    markdown += '\n';
  }
  
  // Добавляем выходы/эвенты
  if (component.outputsClass && component.outputsClass.length > 0) {
    markdown += `**Events:**\n\n`;
    component.outputsClass.forEach(output => {
      markdown += `- \`${output.name}\`: \`${output.type || 'EventEmitter'}\` - ${output.description || 'No description'}\n`;
    });
    markdown += '\n';
  }
  
  // Добавляем публичные методы
  if (component.methodsClass && component.methodsClass.length > 0) {
    const publicMethods = component.methodsClass.filter(method => 
      !method.name.startsWith('ng') && 
      method.modifierKind !== 'private' && 
      method.modifierKind !== 'protected'
    );
    
    if (publicMethods.length > 0) {
      markdown += `**Methods:**\n\n`;
      publicMethods.forEach(method => {
        const params = method.args ? method.args.map(arg => `${arg.name}: ${arg.type || 'any'}`).join(', ') : '';
        const returnType = method.returnType ? `: ${method.returnType}` : '';
        markdown += `- \`${method.name}(${params})${returnType}\` - ${method.description || 'No description'}\n`;
      });
      markdown += '\n';
    }
  }
  
  // Генерируем более умный пример использования
  const example = generateComponentExample(component);
  markdown += `**Example:**\n\`\`\`html\n${example}\n\`\`\`\n\n`;
  
  return markdown;
}

/**
 * Генерирует пример использования компонента
 */
function generateComponentExample(component) {
  const selector = component.selector || 'unknown-component';
  const inputs = component.inputsClass || [];
  const hasSlots = component.selector && (component.selector.includes('button') || 
                    component.selector.includes('section') || 
                    component.selector.includes('list') ||
                    component.selector.includes('cell'));
  
  let example = `<${selector}`;
  
  // Добавляем примеры важных свойств
  const importantInputs = inputs.filter(input => 
    input.optional === false || 
    input.name.includes('text') || 
    input.name.includes('value') || 
    input.name.includes('type') ||
    input.name.includes('mode')
  ).slice(0, 3); // Берем только первые 3 важных
  
  importantInputs.forEach(input => {
    const exampleValue = getExampleValue(input);
    example += `\n  [${input.name}]="${exampleValue}"`;
  });
  
  if (hasSlots) {
    example += `>\n  <!-- Content goes here -->\n</${selector}>`;
  } else {
    example += `></${selector}>`;
  }
  
  return example;
}

/**
 * Генерирует пример значения для свойства
 */
function getExampleValue(input) {
  const type = input.type?.toLowerCase() || '';
  const name = input.name?.toLowerCase() || '';
  
  if (type.includes('string')) {
    if (name.includes('text') || name.includes('label')) return 'Example text';
    if (name.includes('icon')) return 'home';
    if (name.includes('color')) return 'primary';
    if (name.includes('size')) return 'medium';
    return 'example';
  }
  
  if (type.includes('boolean')) return 'true';
  if (type.includes('number')) return '42';
  if (type.includes('array')) return "['item1', 'item2']";
  
  return 'value';
}

/**
 * Генерирует документацию для сервиса
 */
function generateServiceDoc(service) {
  let doc = `#### ${service.name}\n\n`;
  
  if (service.description) {
    doc += `${service.description}\n\n`;
  }

  doc += `**Import:** \`import { ${service.name} } from 'tgui-angular';\`\n\n`;

  // Методы
  if (service.methods && service.methods.length > 0) {
    doc += `**Methods:**\n`;
    service.methods.forEach(method => {
      doc += `- \`${method.name}(`;
      if (method.args && method.args.length > 0) {
        doc += method.args.map(arg => `${arg.name}: ${arg.type || 'any'}`).join(', ');
      }
      doc += `): ${method.returnType || 'void'}\``;
      if (method.description) {
        doc += ` - ${method.description}`;
      }
      doc += '\n';
    });
    doc += '\n';
  }

  return doc;
}

/**
 * Генерирует документацию для директивы
 */
function generateDirectiveDoc(directive) {
  let doc = `#### ${directive.name}\n\n`;
  
  if (directive.selector) {
    doc += `**Selector:** \`${directive.selector}\`\n\n`;
  }
  
  if (directive.description) {
    doc += `${directive.description}\n\n`;
  }

  if (directive.selector) {
    doc += `**Usage:** \`<div ${directive.selector}>Content</div>\`\n\n`;
  }

  return doc;
}

/**
 * Генерирует документацию для интерфейса
 */
function generateInterfaceDoc(iface) {
  let doc = `#### ${iface.name}\n\n`;
  
  if (iface.description) {
    doc += `${iface.description}\n\n`;
  }

  if (iface.properties && iface.properties.length > 0) {
    doc += `**Properties:**\n`;
    iface.properties.forEach(prop => {
      doc += `- \`${prop.name}\`: \`${prop.type || 'any'}\``;
      if (prop.description) {
        doc += ` - ${prop.description}`;
      }
      doc += '\n';
    });
    doc += '\n';
  }

  return doc;
}

/**
 * Генерирует API_SCHEMA.json на основе documentation.json
 */
function generateApiSchema(docData) {
  const schema = {
    libraryInfo: {
      name: "TGUI Angular",
      packageName: "tgui-angular",
      version: docData.miscellaneous?.variables?.find(v => v.name === 'version')?.defaultValue || '1.0.x',
      description: "Comprehensive Angular UI library for building Telegram Web Apps",
      framework: "Angular 14+",
      architecture: "Standalone Components",
      stateManagement: "Angular Signals",
      styling: "CSS Variables + Platform-specific",
      generatedAt: new Date().toISOString()
    },
    installation: {
      command: "npm install tgui-angular",
      requirements: ["Angular 14+", "TypeScript 4.7+"]
    },
    coreSetup: {
      required: true,
      component: "RootComponent",
      selector: "tgui-root",
      import: "import { RootComponent } from 'tgui-angular';",
      usage: "<tgui-root [platform]=\"'ios'\" [appearance]=\"'dark'\"><!-- content --></tgui-root>"
    },
    components: {},
    services: {},
    directives: {},
    interfaces: {}
  };

  // Обрабатываем компоненты
  if (docData.components) {
    docData.components.forEach(component => {
      const componentInfo = {
        name: component.name,
        selector: component.selector,
        description: component.description || '',
        file: component.file,
        properties: {}
      };

      // Добавляем входные свойства
      if (component.inputsClass) {
        component.inputsClass.forEach(input => {
          componentInfo.properties[input.name] = {
            type: input.type || 'any',
            defaultValue: input.defaultValue,
            description: input.description || '',
            optional: !input.optional // Инвертируем, так как compodoc может интерпретировать по-разному
          };
        });
      }

      schema.components[component.name] = componentInfo;
    });
  }

  // Обрабатываем сервисы
  if (docData.injectables) {
    docData.injectables.forEach(service => {
      const serviceInfo = {
        name: service.name,
        description: service.description || '',
        file: service.file,
        methods: {}
      };

      if (service.methods) {
        service.methods.forEach(method => {
          serviceInfo.methods[method.name] = {
            description: method.description || '',
            returnType: method.returnType || 'void',
            parameters: method.args || []
          };
        });
      }

      schema.services[service.name] = serviceInfo;
    });
  }

  // Обрабатываем директивы
  if (docData.directives) {
    docData.directives.forEach(directive => {
      schema.directives[directive.name] = {
        name: directive.name,
        selector: directive.selector,
        description: directive.description || '',
        file: directive.file
      };
    });
  }

  // Обрабатываем интерфейсы
  if (docData.interfaces) {
    docData.interfaces.forEach(iface => {
      const interfaceInfo = {
        name: iface.name,
        description: iface.description || '',
        file: iface.file,
        properties: {}
      };

      if (iface.properties) {
        iface.properties.forEach(prop => {
          interfaceInfo.properties[prop.name] = {
            type: prop.type || 'any',
            description: prop.description || '',
            optional: prop.optional || false
          };
        });
      }

      schema.interfaces[iface.name] = interfaceInfo;
    });
  }

  return schema;
} 
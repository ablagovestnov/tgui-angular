#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * –£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ TGUI Angular
 * 
 * –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
 * 1. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç documentation.json —á–µ—Ä–µ–∑ compodoc (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
 * 2. –°–æ–∑–¥–∞–µ—Ç API_REFERENCE.md –¥–ª—è AI –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
 * 3. –°–æ–∑–¥–∞–µ—Ç API_SCHEMA.json –¥–ª—è –º–∞—à–∏–Ω–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è
 * 4. –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
 * 5. –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
 * 6. –ü–æ–¥—Ä–æ–±–Ω–∞—è –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç—å
 */

const PROJECT_ROOT = path.resolve(__dirname, '..');
const SRC_DIR = path.join(PROJECT_ROOT, 'src');
const DOCS_OUTPUT_DIR = path.join(PROJECT_ROOT, 'docs');
const DIST_DIR = path.resolve(PROJECT_ROOT, '../../dist/tgui');
const CACHE_DIR = path.join(PROJECT_ROOT, '.docs-cache');

console.log('üöÄ Starting Enhanced API Documentation Generation...');
console.log(`üìÅ Project root: ${PROJECT_ROOT}`);
console.log(`üìÅ Source directory: ${SRC_DIR}`);
console.log(`üìÅ Docs output: ${DOCS_OUTPUT_DIR}`);
console.log(`üìÅ Dist directory: ${DIST_DIR}`);

// –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
[DOCS_OUTPUT_DIR, CACHE_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`üìÅ Created directory: ${path.relative(PROJECT_ROOT, dir)}`);
  }
});

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
const config = {
  generateDocumentationJson: true,
  generateApiReference: true,
  generateApiSchema: true,
  validateOutput: true,
  copyToDist: true,
  enableCaching: true,
  verbose: process.argv.includes('--verbose')
};

const stats = {
  startTime: Date.now(),
  components: 0,
  directives: 0,
  services: 0,
  interfaces: 0,
  filesGenerated: []
};

try {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
  if (config.enableCaching && !shouldRegenerate()) {
    console.log('üì¶ Using cached documentation (no source changes detected)');
    copyToDistIfNeeded();
    process.exit(0);
  }

  // –®–∞–≥ 1: –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º documentation.json —á–µ—Ä–µ–∑ compodoc
  console.log('\nüìñ Step 1: Generating documentation.json with compodoc...');
  
  const compodocCommand = buildCompodocCommand();
  
  if (config.verbose) {
    console.log(`üîß Running: ${compodocCommand}`);
  }

  execSync(compodocCommand, { 
    cwd: PROJECT_ROOT,
    stdio: config.verbose ? 'inherit' : 'pipe'
  });

  const documentationJsonPath = path.join(DOCS_OUTPUT_DIR, 'documentation.json');
  
  if (!fs.existsSync(documentationJsonPath)) {
    throw new Error('documentation.json was not generated by compodoc');
  }

  console.log('‚úÖ documentation.json generated successfully');
  stats.filesGenerated.push('documentation.json');

  // –ß–∏—Ç–∞–µ–º –∏ –ø–∞—Ä—Å–∏–º documentation.json
  const docData = JSON.parse(fs.readFileSync(documentationJsonPath, 'utf8'));
  
  // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  stats.components = (docData.components || []).length;
  stats.directives = (docData.directives || []).length;
  stats.services = (docData.injectables || []).length;
  stats.interfaces = (docData.interfaces || []).length;

  // –®–∞–≥ 2: –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º API_REFERENCE.md
  if (config.generateApiReference) {
    console.log('\nüìù Step 2: Generating API_REFERENCE.md...');
    const apiReference = generateApiReference(docData);
    const apiRefPath = path.join(DOCS_OUTPUT_DIR, 'API_REFERENCE.md');
    fs.writeFileSync(apiRefPath, apiReference);
    console.log('‚úÖ API_REFERENCE.md generated successfully');
    stats.filesGenerated.push('API_REFERENCE.md');
  }

  // –®–∞–≥ 3: –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º API_SCHEMA.json
  if (config.generateApiSchema) {
    console.log('\nüîß Step 3: Generating API_SCHEMA.json...');
    const apiSchema = generateApiSchema(docData);
    const apiSchemaPath = path.join(DOCS_OUTPUT_DIR, 'API_SCHEMA.json');
    fs.writeFileSync(apiSchemaPath, JSON.stringify(apiSchema, null, 2));
    console.log('‚úÖ API_SCHEMA.json generated successfully');
    stats.filesGenerated.push('API_SCHEMA.json');
  }

  // –®–∞–≥ 4: –í–∞–ª–∏–¥–∞—Ü–∏—è
  if (config.validateOutput) {
    console.log('\nüîç Step 4: Validating generated documentation...');
    validateDocumentation(docData);
    console.log('‚úÖ Documentation validation passed');
  }

  // –®–∞–≥ 5: –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ dist –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
  if (config.copyToDist) {
    copyToDistIfNeeded();
  }

  // –®–∞–≥ 6: –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
  if (config.enableCaching) {
    updateCache();
  }

  // –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç
  printFinalReport();

  console.log('\nüéâ Enhanced API documentation generation completed successfully!');
  
} catch (error) {
  console.error('\n‚ùå Error generating documentation:', error.message);
  if (config.verbose) {
    console.error(error.stack);
  }
  process.exit(1);
}

/**
 * –°—Ç—Ä–æ–∏—Ç –∫–æ–º–∞–Ω–¥—É compodoc —Å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
 */
function buildCompodocCommand() {
  return [
    'npx compodoc',
    '--tsconfig', path.join(PROJECT_ROOT, 'tsconfig.lib.json'),
    '--output', DOCS_OUTPUT_DIR,
    '--exportFormat', 'json',
    '--name', '"TGUI Angular API Documentation"',
    '--silent',
    '--disableSourceCode',
    '--disableGraph', 
    '--disablePrivate',
    '--disableProtected',
    '--disableInternal',
    '--hideGenerator',
    '--disableDependencies',
    '--disableLifeCycleHooks'
  ].join(' ');
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
 */
function shouldRegenerate() {
  const cacheFile = path.join(CACHE_DIR, 'last-generation.json');
  
  if (!fs.existsSync(cacheFile)) {
    return true;
  }

  try {
    const cacheData = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));
    const lastGenTime = new Date(cacheData.timestamp);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö
    const sourceFiles = getSourceFiles();
    const hasChanges = sourceFiles.some(file => {
      const stat = fs.statSync(file);
      return stat.mtime > lastGenTime;
    });

    return hasChanges;
  } catch {
    return true;
  }
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
 */
function getSourceFiles() {
  const files = [];
  
  function walkDir(dir) {
    if (!fs.existsSync(dir)) return;
    
    fs.readdirSync(dir).forEach(file => {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !file.startsWith('.')) {
        walkDir(fullPath);
      } else if (file.endsWith('.ts') || file.endsWith('.json')) {
        files.push(fullPath);
      }
    });
  }
  
  walkDir(SRC_DIR);
  files.push(path.join(PROJECT_ROOT, 'tsconfig.lib.json'));
  files.push(path.join(PROJECT_ROOT, 'package.json'));
  
  return files;
}

/**
 * –ö–æ–ø–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –≤ dist –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
 */
function copyToDistIfNeeded() {
  if (fs.existsSync(DIST_DIR)) {
    console.log('\nüì¶ Copying documentation to dist...');
    
    stats.filesGenerated.forEach(file => {
      const src = path.join(DOCS_OUTPUT_DIR, file);
      const dest = path.join(DIST_DIR, file);
      if (fs.existsSync(src)) {
        fs.copyFileSync(src, dest);
        console.log(`‚úÖ Copied ${file} to dist`);
      }
    });
  } else {
    console.log('‚ÑπÔ∏è Dist directory not found, skipping copy step');
  }
}

/**
 * –û–±–Ω–æ–≤–ª—è–µ—Ç –∫—ç—à –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
 */
function updateCache() {
  const cacheData = {
    timestamp: new Date().toISOString(),
    stats: stats,
    config: config
  };
  
  fs.writeFileSync(
    path.join(CACHE_DIR, 'last-generation.json'),
    JSON.stringify(cacheData, null, 2)
  );
}

/**
 * –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
 */
function validateDocumentation(docData) {
  const issues = [];

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –±–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è
  const componentsWithoutDesc = (docData.components || []).filter(c => !c.description);
  if (componentsWithoutDesc.length > 0) {
    issues.push(`${componentsWithoutDesc.length} components without description`);
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
  const componentsWithoutSelector = (docData.components || []).filter(c => !c.selector);
  if (componentsWithoutSelector.length > 0) {
    issues.push(`${componentsWithoutSelector.length} components without selector`);
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
  const docJsonPath = path.join(DOCS_OUTPUT_DIR, 'documentation.json');
  const docSize = fs.statSync(docJsonPath).size;
  if (docSize < 10000) { // –ú–µ–Ω—å—à–µ 10KB –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ
    issues.push(`documentation.json is suspiciously small (${Math.round(docSize/1024)}KB)`);
  }

  if (issues.length > 0) {
    console.warn('‚ö†Ô∏è Documentation validation warnings:');
    issues.forEach(issue => console.warn(`   - ${issue}`));
  }
}

/**
 * –í—ã–≤–æ–¥–∏—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
 */
function printFinalReport() {
  const duration = Math.round((Date.now() - stats.startTime) / 1000);
  
  console.log('\nüìä Generation Summary:');
  console.log(`   ‚è±Ô∏è Duration: ${duration}s`);
  console.log(`   üì¶ Components: ${stats.components}`);
  console.log(`   üéØ Directives: ${stats.directives}`);
  console.log(`   üîß Services: ${stats.services}`);
  console.log(`   üìã Interfaces: ${stats.interfaces}`);
  console.log(`   üìÑ Files generated: ${stats.filesGenerated.join(', ')}`);
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —Ñ–∞–π–ª–æ–≤
  console.log('\nüìè File sizes:');
  stats.filesGenerated.forEach(file => {
    const filePath = path.join(DOCS_OUTPUT_DIR, file);
    if (fs.existsSync(filePath)) {
      const size = fs.statSync(filePath).size;
      console.log(`   ${file}: ${formatFileSize(size)}`);
    }
  });
}

/**
 * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ —á–∏—Ç–∞–µ–º–æ–º –≤–∏–¥–µ
 */
function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + 'B';
  if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + 'KB';
  return Math.round(bytes / (1024 * 1024) * 10) / 10 + 'MB';
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç API_REFERENCE.md –Ω–∞ –æ—Å–Ω–æ–≤–µ documentation.json
 */
function generateApiReference(docData) {
  const components = docData.components || [];
  const directives = docData.directives || [];
  const injectables = docData.injectables || [];
  const interfaces = docData.interfaces || [];
  
  let markdown = `# TGUI Angular - API Reference for AI

*Generated automatically from TypeScript source code*

## Library Overview

**TGUI Angular** is a comprehensive Angular UI component library designed specifically for building Telegram Web Apps. It provides modern, accessible components with automatic theme detection and platform-specific styling.

**Package Name:** \`tgui-angular\`
**Installation:** \`npm install tgui-angular\`
**Version:** ${docData.miscellaneous?.variables?.find(v => v.name === 'version')?.defaultValue || '1.0.x'}

## Required Setup

### Root Component (MANDATORY)
\`\`\`typescript
import { RootComponent } from 'tgui-angular';

@Component({
  template: \`
    <tgui-root [platform]="'ios'" [appearance]="'dark'">
      <!-- All app content must be inside tgui-root -->
    </tgui-root>
  \`,
  imports: [RootComponent]
})
\`\`\`

## Components

`;

  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –ø–æ —Ç–∏–ø–∞–º
  const componentGroups = {
    'blocks': [],
    'form': [],
    'typography': [],
    'navigation': [],
    'feedback': [],
    'overlays': [],
    'layout': [],
    'misc': [],
    'utils': []
  };

  components.forEach(component => {
    const filePath = component.file || '';
    let group = 'misc';
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä—É–ø–ø—É –ø–æ –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª—É
    if (filePath.includes('/blocks/')) group = 'blocks';
    else if (filePath.includes('/form/')) group = 'form';
    else if (filePath.includes('/typography/')) group = 'typography';
    else if (filePath.includes('/navigation/')) group = 'navigation';
    else if (filePath.includes('/feedback/')) group = 'feedback';
    else if (filePath.includes('/overlays/')) group = 'overlays';
    else if (filePath.includes('/layout/')) group = 'layout';
    else if (filePath.includes('/utils/')) group = 'utils';

    componentGroups[group].push(component);
  });

  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã
  Object.entries(componentGroups).forEach(([groupName, groupComponents]) => {
    if (groupComponents.length > 0) {
      markdown += `\n### ${groupName.toUpperCase()} Components\n\n`;
      
      groupComponents.forEach(component => {
        markdown += generateComponentDoc(component);
      });
    }
  });

  // –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ä–≤–∏—Å—ã
  if (injectables.length > 0) {
    markdown += `\n## Services\n\n`;
    injectables.forEach(service => {
      markdown += generateServiceDoc(service);
    });
  }

  // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–∏–≤—ã
  if (directives.length > 0) {
    markdown += `\n## Directives\n\n`;
    directives.forEach(directive => {
      markdown += generateDirectiveDoc(directive);
    });
  }

  // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
  if (interfaces.length > 0) {
    markdown += `\n## Interfaces & Types\n\n`;
    interfaces.forEach(iface => {
      markdown += generateInterfaceDoc(iface);
    });
  }

  markdown += `\n## Best Practices for AI Usage

### 1. Always Wrap in Root Component
\`\`\`typescript
// ‚úÖ Correct
<tgui-root>
  <tgui-section>
    <tgui-button>Action</tgui-button>
  </tgui-section>
</tgui-root>

// ‚ùå Incorrect
<tgui-button>Action</tgui-button>
\`\`\`

### 2. Import Strategy
\`\`\`typescript
// ‚úÖ Recommended - Import specific components
import { ButtonComponent, InputComponent } from 'tgui-angular';

// ‚ùå Avoid - Importing everything
import * from 'tgui-angular';
\`\`\`

*This documentation is automatically generated from TypeScript source code and JSDoc comments.*
`;

  return markdown;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
 */
function generateComponentDoc(component) {
  const name = component.name;
  const selector = component.selector || 'N/A';
  const description = component.description || 'No description available';
  const filePath = component.file || '';
  
  let markdown = `#### ${name}\n\n`;
  markdown += `**Selector:** \`${selector}\`\n\n`;
  markdown += `${description}\n\n`;
  
  // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
  if (filePath) {
    const relativePath = filePath.replace(/.*\/src\//, 'src/');
    markdown += `**Source:** \`${relativePath}\`\n\n`;
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç
  markdown += `**Import:**\n\`\`\`typescript\nimport { ${name} } from 'tgui-angular';\n\`\`\`\n\n`;
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–æ–π—Å—Ç–≤–∞/–∏–Ω–ø—É—Ç—ã
  if (component.inputsClass && component.inputsClass.length > 0) {
    markdown += `**Properties:**\n\n`;
    component.inputsClass.forEach(input => {
      const defaultValue = input.defaultValue ? ` (default: \`${input.defaultValue}\`)` : '';
      const required = input.optional === false ? ' **[required]**' : '';
      markdown += `- \`${input.name}\`: \`${input.type || 'any'}\`${required}${defaultValue} - ${input.description || 'No description'}\n`;
    });
    markdown += '\n';
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –≤—ã—Ö–æ–¥—ã/—ç–≤–µ–Ω—Ç—ã
  if (component.outputsClass && component.outputsClass.length > 0) {
    markdown += `**Events:**\n\n`;
    component.outputsClass.forEach(output => {
      markdown += `- \`${output.name}\`: \`${output.type || 'EventEmitter'}\` - ${output.description || 'No description'}\n`;
    });
    markdown += '\n';
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –ø—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã
  if (component.methodsClass && component.methodsClass.length > 0) {
    const publicMethods = component.methodsClass.filter(method => 
      !method.name.startsWith('ng') && 
      method.modifierKind !== 'private' && 
      method.modifierKind !== 'protected'
    );
    
    if (publicMethods.length > 0) {
      markdown += `**Methods:**\n\n`;
      publicMethods.forEach(method => {
        const params = method.args ? method.args.map(arg => `${arg.name}: ${arg.type || 'any'}`).join(', ') : '';
        const returnType = method.returnType ? `: ${method.returnType}` : '';
        markdown += `- \`${method.name}(${params})${returnType}\` - ${method.description || 'No description'}\n`;
      });
      markdown += '\n';
    }
  }
  
  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–æ–ª–µ–µ —É–º–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
  const example = generateComponentExample(component);
  markdown += `**Example:**\n\`\`\`html\n${example}\n\`\`\`\n\n`;
  
  return markdown;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
 */
function generateComponentExample(component) {
  const selector = component.selector || 'unknown-component';
  const inputs = component.inputsClass || [];
  const hasSlots = component.selector && (component.selector.includes('button') || 
                    component.selector.includes('section') || 
                    component.selector.includes('list') ||
                    component.selector.includes('cell'));
  
  let example = `<${selector}`;
  
  // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–º–µ—Ä—ã –≤–∞–∂–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤
  const importantInputs = inputs.filter(input => 
    input.optional === false || 
    input.name.includes('text') || 
    input.name.includes('value') || 
    input.name.includes('type') ||
    input.name.includes('mode')
  ).slice(0, 3); // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 3 –≤–∞–∂–Ω—ã—Ö
  
  importantInputs.forEach(input => {
    const exampleValue = getExampleValue(input);
    example += `\n  [${input.name}]="${exampleValue}"`;
  });
  
  if (hasSlots) {
    example += `>\n  <!-- Content goes here -->\n</${selector}>`;
  } else {
    example += `></${selector}>`;
  }
  
  return example;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∏–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å–≤–æ–π—Å—Ç–≤–∞
 */
function getExampleValue(input) {
  const type = input.type?.toLowerCase() || '';
  const name = input.name?.toLowerCase() || '';
  
  if (type.includes('string')) {
    if (name.includes('text') || name.includes('label')) return 'Example text';
    if (name.includes('icon')) return 'home';
    if (name.includes('color')) return 'primary';
    if (name.includes('size')) return 'medium';
    return 'example';
  }
  
  if (type.includes('boolean')) return 'true';
  if (type.includes('number')) return '42';
  if (type.includes('array')) return "['item1', 'item2']";
  
  return 'value';
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞
 */
function generateServiceDoc(service) {
  let doc = `#### ${service.name}\n\n`;
  
  if (service.description) {
    doc += `${service.description}\n\n`;
  }

  doc += `**Import:** \`import { ${service.name} } from 'tgui-angular';\`\n\n`;

  // –ú–µ—Ç–æ–¥—ã
  if (service.methods && service.methods.length > 0) {
    doc += `**Methods:**\n`;
    service.methods.forEach(method => {
      doc += `- \`${method.name}(`;
      if (method.args && method.args.length > 0) {
        doc += method.args.map(arg => `${arg.name}: ${arg.type || 'any'}`).join(', ');
      }
      doc += `): ${method.returnType || 'void'}\``;
      if (method.description) {
        doc += ` - ${method.description}`;
      }
      doc += '\n';
    });
    doc += '\n';
  }

  return doc;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –¥–∏—Ä–µ–∫—Ç–∏–≤—ã
 */
function generateDirectiveDoc(directive) {
  let doc = `#### ${directive.name}\n\n`;
  
  if (directive.selector) {
    doc += `**Selector:** \`${directive.selector}\`\n\n`;
  }
  
  if (directive.description) {
    doc += `${directive.description}\n\n`;
  }

  if (directive.selector) {
    doc += `**Usage:** \`<div ${directive.selector}>Content</div>\`\n\n`;
  }

  return doc;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
 */
function generateInterfaceDoc(iface) {
  let doc = `#### ${iface.name}\n\n`;
  
  if (iface.description) {
    doc += `${iface.description}\n\n`;
  }

  if (iface.properties && iface.properties.length > 0) {
    doc += `**Properties:**\n`;
    iface.properties.forEach(prop => {
      doc += `- \`${prop.name}\`: \`${prop.type || 'any'}\``;
      if (prop.description) {
        doc += ` - ${prop.description}`;
      }
      doc += '\n';
    });
    doc += '\n';
  }

  return doc;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç API_SCHEMA.json –Ω–∞ –æ—Å–Ω–æ–≤–µ documentation.json
 */
function generateApiSchema(docData) {
  const schema = {
    libraryInfo: {
      name: "TGUI Angular",
      packageName: "tgui-angular",
      version: docData.miscellaneous?.variables?.find(v => v.name === 'version')?.defaultValue || '1.0.x',
      description: "Comprehensive Angular UI library for building Telegram Web Apps",
      framework: "Angular 14+",
      architecture: "Standalone Components",
      stateManagement: "Angular Signals",
      styling: "CSS Variables + Platform-specific",
      generatedAt: new Date().toISOString()
    },
    installation: {
      command: "npm install tgui-angular",
      requirements: ["Angular 14+", "TypeScript 4.7+"]
    },
    coreSetup: {
      required: true,
      component: "RootComponent",
      selector: "tgui-root",
      import: "import { RootComponent } from 'tgui-angular';",
      usage: "<tgui-root [platform]=\"'ios'\" [appearance]=\"'dark'\"><!-- content --></tgui-root>"
    },
    components: {},
    services: {},
    directives: {},
    interfaces: {}
  };

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
  if (docData.components) {
    docData.components.forEach(component => {
      const componentInfo = {
        name: component.name,
        selector: component.selector,
        description: component.description || '',
        file: component.file,
        properties: {}
      };

      // –î–æ–±–∞–≤–ª—è–µ–º –≤—Ö–æ–¥–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
      if (component.inputsClass) {
        component.inputsClass.forEach(input => {
          componentInfo.properties[input.name] = {
            type: input.type || 'any',
            defaultValue: input.defaultValue,
            description: input.description || '',
            optional: !input.optional // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º, —Ç–∞–∫ –∫–∞–∫ compodoc –º–æ–∂–µ—Ç –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ-—Ä–∞–∑–Ω–æ–º—É
          };
        });
      }

      schema.components[component.name] = componentInfo;
    });
  }

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
  if (docData.injectables) {
    docData.injectables.forEach(service => {
      const serviceInfo = {
        name: service.name,
        description: service.description || '',
        file: service.file,
        methods: {}
      };

      if (service.methods) {
        service.methods.forEach(method => {
          serviceInfo.methods[method.name] = {
            description: method.description || '',
            returnType: method.returnType || 'void',
            parameters: method.args || []
          };
        });
      }

      schema.services[service.name] = serviceInfo;
    });
  }

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∏—Ä–µ–∫—Ç–∏–≤—ã
  if (docData.directives) {
    docData.directives.forEach(directive => {
      schema.directives[directive.name] = {
        name: directive.name,
        selector: directive.selector,
        description: directive.description || '',
        file: directive.file
      };
    });
  }

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
  if (docData.interfaces) {
    docData.interfaces.forEach(iface => {
      const interfaceInfo = {
        name: iface.name,
        description: iface.description || '',
        file: iface.file,
        properties: {}
      };

      if (iface.properties) {
        iface.properties.forEach(prop => {
          interfaceInfo.properties[prop.name] = {
            type: prop.type || 'any',
            description: prop.description || '',
            optional: prop.optional || false
          };
        });
      }

      schema.interfaces[iface.name] = interfaceInfo;
    });
  }

  return schema;
} 